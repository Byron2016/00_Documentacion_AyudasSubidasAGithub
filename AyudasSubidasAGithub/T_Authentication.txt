- Formas de implementar autenticaci√≥n
	- JSON Web Tokens (JWT)
	- Sessions
	-

- CSRF
	- Read about CSRF: https://owasp.org/www-community/attacks/csrf

- JWT
	- ByteGyteGo: Why is JWT popular?
		- https://www.youtube.com/watch?v=P2CPd9ynFLg
			- Content
			- 1.- {"what" : "json"}
			- 2.- JWT Structure
			- 3.- Working?
			- 4.- Sinning Alg
			- 5.- Attack Scenario


			- 1.- {"what" : "json"}
				- JSON Web Tokens let your identity travel the web securely.
				- But like losing your passpord, a stolen JWT gives hackers full access.
				- In this video, we'll unlock the immense potential of JWTs, and the dangers lurking withing.
				- JWT are a robust method for secureley transmitting information between parties as JSON objets.
				- JSON is a lightweight data interchange format that¬¥s easy to read and write for humans and simple for machines to parse and generate.
				- Claims
					- They are stored inside the payload (carga √∫til) of a JWT
					- Claims are statements about an entity, whici is typically the user with some additional data.
					- Types
						- Public
						- Registered
						- Private

					- Registered Claims
						- They are predefined, like the issuer, expiration time, and subject.

				- Signing these tokens
					- Signing is like sealing an envelope with a wax stamp to ensure it hasn¬¥t been tampered with.

					- Signing algorithms Types
						- Symmetric algorithms: HMAC SHA256
							- Use a shared secret key for both signing and verification.
						- Asymmetric algorithms: RSA
							- Use a pubic/private key pair where the private key signs the token and the public key verifies it.
					- Signed JWT provide
						- Authentication
						- Authorizacion
						- Information Exchange

					- Login
						- User send login request
						- Server creates a signed JWT with user details and send it back (Validate credentials)
						- Client uses this to access protected resources by sending the token in the HTTP header.

							1. User Login / username, password
							2. Server Validate credentias
							3. Server Create & sign JWT with secret
							   Send Authorization: Bearer JWT
							4. User Store JWT locally
							5. User request /resource/user
							   Authorization: Bearer JWT
							6. Server Validate signature
							   OK
							   return data.

				- When do not use JWT
					- The payload (carga √∫til) is not encrypted by default so should not contain highly sensitive data.
					- JWTs aren¬¥t ideal for managing user sessions since they are stateless. Revoking JWT access can be challenging.
					- Some common vulnerabilities to be aware of include token hijacking, where an attacker steals a valid JWT to impersonate a user.
					- JWT¬¥s also could be vulnerable to cryptographic weaknesses if using weak hashing algorithms. Automated brute force attacks may try to crack token signatures.

				- Mitigate risks when using JWT
					- Keeping JWT payloads (carga √∫til) with only the necessary user claims;
					- Using short token expiration times when possible
					- Storing tokens securely and invalidating any leaked tokens.
					- Using strong signature algorithms



	- Midudev: Aprende Autenticaci√≥n de Usuario, Sesi√≥n, Cookies y JWT con Node.js
		- https://www.youtube.com/watch?v=UqnnhAZxRac&t=13s
			- Contenido
				- Instalaci√≥n del proyecto
				- Usuarios en base de datos
			- Registro de usuarios
			- Autenticaci√≥n b√°sica con login y password
			- Verificaci√≥n de autenticaci√≥n - Usando hashes y salts
			- Sesi√≥n de usuario con cookie
			- Rutas protegidas
			- Json Web Tokens
			- Refactorizar con un middleware
			- Cerrar sesi√≥n
			- Refresh token
			- M√°s adelante: Passport y Outh 2.0


			- Instalaci√≥n del proyecto
				- pnpm init
				- package.json
					- type: module
					- script: "dev": "node --watch index.js"
					- Ejecutar: pnpm run dev / pnpm dev / node --run dev
				- crear index.js
				- pnpm add express
				- Slint
					- pnpm add -D standard
					- "eslintConfig": {
					    "extends": "standard"
					  }
				- Variables
					- Crear un "config.js"
						export const {
						PORT = 3000
						} = process.env

					- En el index.js
						import { PORT } from "./config.js"

				- Para End points usaremos Yaak.
					- https://yaak.app/download


			- Usuarios en base de datos
				- Conceptos
					- ORM (Object Relational Mapper)
						- Un ORM es la capa entre la base de datos y su aplicaci√≥n. Us√°ndolo gran parte del trabajo de un CRUD viene hecho.
						- En un ORM se trabaja con objetos como su mayor punto de referencia. Cuando se trabaja con objetos en nuestras aplicaciones, trabajamos con un √∫nico objeto que almacena todas las propiedades del objeto y relaciones (Pese a que la data es almacenada en valores individuales a trav√©s de varias tablas en una DB).

						- Tipos de implementaci√≥n de ORMs
							- Data mapper pattern
							- Active Record pattern

						- Data mapper pattern vs Active Record pattern
							- https://en.wikipedia.org/wiki/Data_mapper_pattern
							- What's the difference between Active Record and Data Mapper?
								- https://culttt.com/2014/06/18/whats-difference-active-record-data-mapper
							- How We Code: ORMs and Anemic Domain Models by Chris Fidao.

						- Active Record pattern
							- Es el m√°s popular (Laravel lo usa)
							- Uso
								- Crea un nuevo objeto "User"
									- $user = new User();
								- Asigna valores a propiedades del objeto "User"
									- $user->username = "philipbrown";
								- Mapea el objeto "User" a una fila de la tabla "users"
									- $user->save();

							- Caracter√≠sticas
								- El objeto "User" no tiene que tener especificado las propiedades y como estas se relacionan con la base de datos. Esto lo hace autom√°ticamente "Active Record stype ORMs", el modelo es capaz de determinar las propiedades del modelo autom√°ticamente solo con mirar el schema de la base de datos.

							- Ventajas
								- Se puede tan solo llamar al m√©todo save() del objeto para actualizar la DB. Cada model object hereda del objeto base Active Record y de esa forma tiene acceso a todos los m√©todos de persistencia.
								- Le hace que sea muy f√°cil para iniciar por ser muy intuitivo.

						- Data mapper pattern
							- La gran diferencia con Active Record es que separa completamente su "dominio" de la "capa de persistencia", esto significa que ninguno de los objetos sabe nada sobre la DB.

							- Uso
								- Crea un nuevo objeto "User"
									- $user = new User();
								- Asigna valores a propiedades del objeto "User"
									- $user->username = "philipbrown";

								- NO tiene ning√∫n conocimiento sobre la base de datos, esto es no se puede llamar al m√©todo "save()" en el objeto para persistirlo en la DB por que no existe.

								- Usar un servicio completamente diferente conocido como "Entity Manager"
									- EntityManager::persist($user);

							- Ventajas
								- Sus objetos del dominio NO necesitan saber nada sobre como est√°n almacenados en la DB.
								- Sus objetos ser√°n m√°s livianos porque no tendr√°n que heredar el ORM completo.
								- Habr√° que ser m√°s estricto y tener un proceso m√°s formal para interactuar con la DB porque no se puede llamar simplemente al m√©todo "save()" en ninguna parte de su c√≥digo.

						- Diferencias entre Data mapper pattern vs Active Record pattern
							- El tipo de aplicaci√≥n a ser constru√≠da.
								- Hay dos tipos
									- Aplicaciones basadas en CRUD
									- Aplicaciones basadas en Dominio (Domain).


								- Aplicaciones basadas en CRUD
									- C√≥digo mapea limpiamente a la DB
									- Typicamente para CRUD
									- Se pueden tener relaciones entre los modelos, pero la mayor parte, no hay reglas estrictas alrededor de esas relaciones que deban ser reforzadas.
									- Ideal para "Active Record"

								- Aplicaciones basadas en Dominio (Domain).
									- Enfocada en satisfacer las reglas y procedimientos del negocio.
									- Permite reforzar ciertas restricciones hacer cumplir ciertas restricciones en el manejo de datos y la persistencia
									- Ideal para "Data mapper"

							- Aplicaci√≥n y entorno en que se est√° construyendo
								- "Active Record"
									-  Minimum viable product

								- "Data mapper"
									- Negocio existente para crear una nueva aplicaci√≥n a partir de un sistema heredado.
									- Una empresa existente ya tendr√° reglas y procedimientos sobre c√≥mo funciona su negocio. Al utilizar el patr√≥n Active Record, terminar√° intentando forzar que esas reglas comerciales funcionen bien con la "mentalidad de base de datos" de Active Record. El patr√≥n Data Mapper te permitir√° encapsular las reglas de dominio del negocio para que trabajar con la aplicaci√≥n sea claro e intuitivo.
				- Validaciones
					- Usar zod

				- Usaremos base de datos en memoria.
					- pnpm install db-local
				- Crear user-repository.js
					- importar db-local
					- crear clase UserRepository y crear m√©todos est√°ticos.
						import DBLocal from 'db-local'
						export class UserRepository{
						  static create ({username, password}){}
						  static login ({username, password}){}
						}
					- Crear un Schema
						const { Schema } = new DBLocal({ path: './db/'})
						const User = Schema('user', {
						  _id: {type: String, required: true},
						  username: {type: String, required: true},
						  password: {type: String, required: true},
						})

			- Sesi√≥n de usuario con cookie
				- Cookies
					- Las cookies no van a desaparecer, tan solo las third party cookies (anal√≠ticas, publicidad, traqueo, etc), las del propie dominio no pasa nada.
					- Menos vulnerables a ataques XSS
					- no se pueden leer desde java script
					- Colocar la vandera de la cookie httpOnly
					- Poner tiempo de expiraci√≥n
					- Se pueden configurar env√≠o solo por https
						- Evitar man in the middle
					- Se puede hacer que la cookie solo se env√≠e a domineos que son del tuyo propio.
					- Se env√≠a
					- Uso:
						- pnpm install cookie-parser
						- import cookieParser from "cookie-parser"
						- app.use(cookieParser())
						- res
							.cookie("access_token", token, {
								httpOnly:true, // la coodie solo se puede acceder en el servidor.
								secure: process.env.NODE_ENV === "production", // la coodie solo se puede acceder en https
								sameSite: "strict", //la cookie sole se puede acceder en el mismo dominio
								maxAge: 1000*60*60 //la cookie tiene un timepo de validez de 1 hora.
							})
						- Agregar un middleware
							app.use((req, res, next) =>{
								const token = req.cookies.access_token
								//let data = null
								req.session = {user: null}
								try{
									const data = jwt.verify(token, SECRET_JWT_KEY)
									req.session.user = data
								} catch { }
								next()
							})
							app.get("/",(req,res) => {
								/*
								const token = req.cookies.access_token
								if(!token) return res.render("index")


								try{
									const data = jwt.verify(token, SECRET_JWT_KEY)
									res.render("index", data)
								} catch(error) { res.render("index")}
								next()
								*/
								const {user} = req.session
								res.render("index", user)

							})
						- cerrar session
							res
								.clearCokkie("access_token")
								.json({message: "Logout successful"})
				- Session y Locage storage
					- Son suceptibles a ataque "enviar solicitud desde navegador del usuario, sin que el usuario se entere" se hace mucho en css, se llama CSRF "Cross Site Request forgery"
					- Son accesibles de java script
					-
	- https://www.youtube.com/watch?v=8RiDRdHPcxA&list=PL4cUxeGkcC9iqqESP8335DA5cRFp8loyp&index=8
	- Debuger
		- https://jwt.io/
	- Partes
		- Header
			- Le dice al servidor que tipo de firma est√° siendo usada (meta)
		- Payload (carga √∫til)
			- Usado para identificar el usuario (ejem: contiene user id)
		- Signature
			- Hace el token seguro (like a stampo of authenticity / como un sello de autenticidad)

  - Ciclo Vida JWT
    - üîêCiclo de vida de JWT | SEGURIDAD INFORM√ÅTICAüõ°Ô∏è
      - https://www.youtube.com/watch?v=capnr5ULxGQ
        - Ciclo vida jwt
          - Creaci√≥n
          - Trasmisi√≥n
          - Validaci√≥n
          - Uso de Claims
          - Actualizaci√≥n
          - Expiraci√≥n

        - Explicaci√≥n: Ciclo vida jwt
          - Creaci√≥n
            - Usuario "inicia Sesi√≥n" en Cliente
            - FrontEnd (Cliente) hace "petici√≥n de token"
            - Servidor "Genera JWT"
            - Usuario "Recibe jwt" del cliente.
          - Trasmisi√≥n
            - Usuario "Env√≠a solicitud con JWT" dentro de la cabecera
            - Cliente "Env√≠a solicitud con JWT"
            - Servidor "Procesa solicitud con JWT"
            - Usuario "Recibe una respuesta" desde el cliente.
          - Validaci√≥n
            - Usuario "Env√≠a solicitud con JWT" a trav√©s del cliente directamente al servidor.
            - Servidor "Valida firma y expiraci√≥n"
            - Usuario "Respuesta con validaci√≥n exitosa" desde servidor.
          - Uso de Claims
            - Servidor "utiliza informaci√≥n de claims" enviada con anterioridad
              - Claims vienen en el "payload" / carga √∫til
            - Usuario "realiza acci√≥n autorizada" desde servidor.
          - Actualizaci√≥n
            - Usuario "inicia sesi√≥n nuevamente" al cliente
            - Cliente "Petici√≥n de nuevo token"
            - Servidor "Genera nuevo JWT"
            - Usuario "Recibe nuevo JWT" del cliente.
          - Expiraci√≥n
            - Servidor "Verifica fecha de expiraci√≥n"
            - Servidor "JWT ha expirado"
            - Usuario "Respuesta de expiraci√≥n de JWT" desde servidor.

  - Autenticaci√≥n JWT
    - ¬øC√≥mo se autentica un servidor en otro? Server-To-Server Auth con JWT y RSA
      - https://www.youtube.com/watch?v=0NiyW9XINRA
        - curl -H "Authorization: token <>" https://api.github.com/user/repos
        - RSA (25.24)
          - Clave p√∫blico privada
          - Criptograf√≠a asim√©trica
            - En servidor se guardan "claves p√∫blicas de los clientes
            - En clientes se guardan "claves privadas"
            - Clientes firmaran un JWT con sus "claves privadas" al llegar al servidor podremos validar las firmas utilizando sus "claves p√∫blicas"
            - Si te hakean la "clave p√∫blica" no sirve de nada ya que solo se usan para validar "claves privadas" que las almacenan los clientes. Es decir deber√≠an hakear a un servidor cliente y sacarle la "privada" solo podr√≠an hacerse pasar por ese cliente y no por todos como pasar√≠a en JWT auto firmado.
              - Generar claves privada-p√∫blica
                - s s h-k e y g e n -t rsa -b 4096 -m PEM -f jwtRS256.key
                  - Genera dos archivos .key que es la privada y un . pub que es la p√∫blica.
              - Sobre escribir la p√∫blica generada al mismo formato de la .key
                - o p e n s s l   r s a -in <la key> -pubout -outform PEM -out <la key pub>

              - javascript
                const privateKey = await fs.readFile('la key', 'utf-8')

                const token = jwt.sign({}, privateKey, {algorithm: 'RS256'})

                const response = await axios.get('htp://localhost:8000/api/rsa/repos', {
                  headers: {
                    Authorization: `token ${token}`
                  }
                })

                res.json(response.data)

- pnpm add -g typeorm
- pnpm list -g

- npx typeorm init --name MyProject --database postgres
-  typeorm init --name test_uno --database mysql --express

- Quitar
	- body-parser
	- typescript
- Instalar
	- dependencies
		pnpm add cors jsonwebtoken bcryptjs class-validator
	- devDependencies
		pnpm add -D ts-node-dev typescript @types/bcryptjs  @types/cors @types/jsonwebtoken @types/express @types/node

mysql://avnadmin:AVNS_o8DhGOB553w2LUHkdwU@mysql-node-bgva2005-5985.h.aivencloud.com:26885/defaultdb?ssl-mode=REQUIRED

mysql://avnadmin:AVNS_o8DhGOB553w2LUHkdwU@mysql-node-bgva2005-5985.h.aivencloud.com:26885/defaultdb?ssl-mode=REQUIRED

defaultdb

  code: 'ER_NOT_SUPPORTED_AUTH_MODE',
  errno: 1251,
  sqlMessage: 'Client does not support authentication protocol requested by server; consider upgrading MySQL client',
  sqlState: '08004',
  fatal: true

connect to Aiven for Mysql with nodejs

- Formas de implementar autenticaci√≥n
	- JSON Web Tokens (JWT)
	- Sessions
	-

ü§£ü§£ü§£ü§£ de verdad? que animal, gracias por dec√≠rmelo voy a borrar y volverlo a poner.

- Env√≠o de emails
	- pnpm install nodemailer
	- En Google
		- Ir a google: google.com
		- Presionar en "Cuenta de Google"
		- Seleccionar "Gestionar tu cuenta de Google"
		- Seleccionar "Seguridad"
		- En "C√≥mo inicias sesi√≥n en Google" seleccionar "Verificaci√≥n en dos pasos"
		- Poner tel√©fono
		- Volver a "Seguridad"
		- Tus conexiones con aplicaciones y servicios de terceros
		- myaccount.google.com/apppasswords
		- Nombre de la aplicaci√≥n: AdminApi
			- Crear
		- Tu contrase√±a de aplicaci√≥n para el dispositivo
			- lbwa nrce axoy apjt

- mailer.ts
	import nodemailer = requiere("nodemailer");

	const transporter = nodemailer.createTransport({
	host: "smtp.gmail.com",
	port: 465,
	secure: true, // Use `true` for port 465, `false` for all other ports
	auth: {
		user: "byron.valdivieso2020@gmail.com",
		pass: "lbwa nrce axoy apjt",
	},
	});

	transporter.verify().then(() => {
		console.log("Ready for send emails.");
	});

- AuthController.ts
	import config from "./../config/mailer";

	class AuthController  {
		static forgotPassword = async(req: Request, res: Response) => {
			....
			try{
				const info = await transporter.sendMail({
					from: '"Forgot password üëª" <maddison53@ethereal.email>', // sender address
					to: user.username // list of receivers
					subject: "Forgot password ‚úî", // Subject line
					text: "Hello you have forgoten your password?", // plain text body
					html: `
						<b>Please click on the following link, or paste this into your browser to complete the process:</b>
						<a href="${verificationLink}">${verificationLink}</a>
					`
					"", // html body
				});
				console.log("Message sent: %s", info.messageId);
			} catch(error){
				emailStatus = error;
				return res.status(400).json({ message: 'Something goes wrong!' });
			}

		}
	}



- Stack tecnol√≥gico
	- servidor en nodejs
	- express
	- typescript
	- typeORM
	- mysql
	- jwt
	- roles: Admin, reader
	- Thunder Client (api tester)
	- Extensi√≥n REST client
		- Para probar APIS.
		- crear archivo api.http
		- Ejemplo
			- ### para recuperar x cosas.
			  GET http://localhost:1234/movies


- pasos
	- pnpm i typeorm -g
	- typeorm init --name login_roles --database mysql --express
	- Actualizar dependencias a √∫ltima versi√≥n
	- A√±adir/Quitar dependencias
		- Quitar
			- body-parser
			- typescript
		- Instalar
			- dependencies
				pnpm add cors jsonwebtoken bcryptjs class-validator dotenv helmet nodemailer
					- bcryptjs: Encriptar el password
					- class-validator: Validaciones campos de la base de datos.
					- cors: Aceptar todas las peticiones hechas desde un front end
					- jsonwebtoken: Para crear y leer JWT

			- devDependencies
				pnpm add -D ts-node-dev typescript @types/bcryptjs  @types/cors @types/jsonwebtoken @types/express @types/node
					- Tipos para typescript
						- @types/bcryptjs:
						- @types/cors:
						- @types/express:
						- @types/jsonwebtoken:
					- ts-node-dev: Reiniciar servidor

	- tsconfig.json
		- "outDir": "./dist",
		- "rootDir": "./src",

	- update package.json
		- crear scripts
			- "tsc": "tsc",
			- "dev": "ts-node-dev --respawn --transpile-only ./src/index.ts"

	- DataBase
		- Configuraci√≥n
			- Agregar archivo ".env" a ra√≠z proyecto.
				DB_DATABASE_URL= "xxxx"
				DB_DATABASE_PORT = 3306
				DB_DATABASE_USERNAME= "xxxx"
				DB_DATABASE_PASSWORD= "xxxx"
				DB_DATABASE_NAME= "xxxx"
			- Agregar paquete "dotenv"
				- pnpm add dotenv

			- data-source.ts
				- Importar variables entorno a "data-source.ts"
					- const dotenv = require("dotenv");
				- dotenv.config();
				- host: process.env.DB_DATABASE_URL,
		- Crear
			- mysql -uroot -p
			- show databases;
			- create database login_node;
			- use login_node;

		- Error
			- sqlMessage: 'Client does not support authentication protocol requested by server; consider upgrading MySQL client',
				- SOLUCI√ìN
					- ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';

			- Type 'string' has no properties in common with type 'FindOneOptions<User>'
				- SOLUCI√ìN
					-

		-Testear
			- pnpm dev
			- http://localhost:3000/users

		- Seguridad
			- Deshabilitar el header X-Powered-By: Express
				- app.disable("x-powered-by");

	- Encriptar password
		- pnpm i bcript
		- import * as bcrypt from "bcryptjs";
		- Crear funciones para encriptar y comparar
			hashPassword(): void {
				const salt = bcrypt.genSaltSync(parseInt(process.env.PASS_SALT, 10));
				this.password = bcrypt.hashSync(this.password, salt);
			}

			checkPassword(password: string): boolean {
				return bcrypt.compareSync(password, this.password);
			}
		- Actualizar UserController.newUser
			- user.hashPassword();
		- Actualizar authController.Login

			if (!user.checkPassword(password)) {
			return res
				.status(400)
				.json({ message: "Username or Password are incorrect!" });
			}

	- Agregar JWT
		- Crear carpeta middlewares
		- Agregar jwt.ts
		- Crear la funci√≥n checkJwt como middleware
		- Error: Cannot set headers after they are sent to the client
			- hay un res.send(user); luego de un res.json()

	- Class-Validate
		- Controlar lo que devuelve.
			- const errors = await validate(user);
				- Devuelve
					- un array con un ValidationError que tiene un target que a su vez tiene x ejemplo el password.
					- un value
			- Corregir:
				- const validationOpt = { validationError: { target: false, value: false } };
				  const errors = await validate(user, validationOpt);

	- Usuario Cambiar contrase√±a


	- Conceptos
		- REST API (otra SOAT)
			- Representetional State Transfert
			- Arquitectura de software
			- Nace en a√±o 2000 - Roy Fielding
			- Principios
				- Escabilidad
				- Simplicidad
				- Visibilidad
				- Portabilidad
				- Fiabilidad
				- Modificabilidad (f√°cil de modificar)
			- Fundamentos
				- Resources
					- Todo es considerado un recurso
					- Cada recurso se va a identificar con una URL
						- Ejemp: Todos los recursos que sean MOVIES se identifican con /movies
				- Verbos HTTP
					- Para definir las operaciones que se pueden realizar con los recursos.
				- Representaciones
					- JSON, XML, HTML, etc
					- El cliente deber√≠a poder dicidir la representaci√≥n del recurso.
					- Ejemp: Podr√≠a en en par√°metros que me indique si quiere que me devuelva JSON u otro.
				- Staleless
					- El cliente debe enviar toda la informaci√≥n necesaria para procesar la request.
					- Servidor NO guarda informaci√≥n para responder al cliente (osea para saber como debe hacerlo). Todo debe estar inclu√≠do en el URL.
				- Interfaz uniforme
				- Separaci√≥n de conceptos
					- Permite que cliente y servidor evolucionen de forma separada.


		- path-to-regexp
			- "/movies/:id/:mas/:otro"
			- const {id, mas, otro}
			- express usa path-to redexp al igual que react router
			- convierte el path directamente a expresiones regulares
			- "/ab+cd/" -> abcd, abd ...
			- "/ab(cd)e/" -> abe, abce ...
			- "dev$" -> que termine en dev.

		- POST VS PATCH VS PUT
			- Idempotencia
				- Propiedad de realizar una acci√≥n determinada varias veces y a√∫n as√≠ conseguir siempre el mismo resultado que se obtendr√≠a al hacerlo una vez.
				- Funciones puras son idempotentes.
			- POST
				- Prop√≥sito: Crear un nuevo elemento/recurso en el servidor.
				- /movies
				- NO es idempotente
			- PUT
				- Prop√≥sito: Actualizar totalmente un elemento/recurso ya existente o crearlo si no existe.
				- /movies/123
				- SI es idempotente el resultado siempre ser√° el mismo. pero depende, por si tiene un updateAt.
			- PATCH
				- Prop√≥sito: Actualizar parcialmente un elemento/recurso.
				- /movies/123
				- SI es idempotente en principio, pero depende, por si tiene un updateAt.

		- Validaciones
			- Zod, superStruct, io, yup, ....
			- Typescript NO sirve para tiempo de run time.
			- ZOD
				- pnpm i zod
				- Crear carpeta schemas
				- Crear carpeta movies
				- const z = require("zod")
				- Crear esquema
					- const movieSchema = z.object({
						title: z.string({
							invalid_type_error: "Movie title must be a string",
							required_error: "Movie title is required"
						}),
						year: z.number().int().min(1900).max(2024).positive(),
						poster: z.string().url({invalid_type_error: "Movie title must be a string",}),
						genre: z.array(
							z.enum(["","",""],{opciones de error})
						)
					})
				- Crear funciones
					- functio validateMovie(object) {
						return movieSchema.parse(object)
						// MEJOR
						return movieSchema.safeParse(object)
							// retorna un objeto resolve que te va a decir si hay un error o datos.
					}
					module.exports = {validateMovie}
				- Usar el servicio de validaci√≥n
					- app.post("/movies", () => {
						const result = validateMovie(req.body)
						if(result.error){retornar error}
						const newMovie = {
							id: crypto.randomUUID(),
							...result.data
						}
						movies.push(newMovie)
					})


	- CORS
		- Cross origin resource sharing (error de uso compartido de recursos entre dominios)
		- BackEnd responde sin headers
		- No hay una cabecera que diga que el dominio solicitante localhost:8000 puede solicitar al dominio orignen localhost:3000
		- Soluci√≥n
			- Se lo hace en la parte el backend ya sea en la api, proxy, enrutador, en lo que sea que tengas que pueda a√±adir esa cabecera.
			- Todos los or√≠genes son permitidos.
				- res.header("Access-Control-Allow-Origin", "*")

			- Un origen espec√≠fico.
				- res.header("Access-Control-Allow-Origin", "http://localhost:8000")
			- Detectar el origen y ver que es lo que se hace.
				- const ACCEPTED_ORIGINS = [
					"http://localhost:8000",
					"http://localhost:8001"
				]

				- app.get("", () => {
					const origin = req.headers("origin")

					ver si est√° en lista de or√≠genes aceptados.

					if(ACCEPTED_ORIGINS.includes(origin) || !origin) {....}
				})

				- No siempre solicitante env√≠a el origen.
					- Cuando
						- Si la petici√≥n es del mismo origen.
							- http://localhost:1234  -> http://localhost:1234

				- CORS PRE-Flight
					- m√©todo normales: GET/HEAD/POST
					- M√©todos complejos: PUT/PATCH/DELETE
						- Generan el CORS PRE-Flight
						- Requiere una petici√≥n especial que se llama OPTIONS
						- lo que va a hacer es preguntarle a la API utilizando el verbo OPTIONS y ve si tiene la cabecera CORS
					- SOLUCI√ìN
						- Agregar en el API un
							- app.options("/movies/:id", (req, res) => {
								const origin = req.header("origin")

								if(ACCEPTED_ORIGINS.includes(origin) || !origin) {
									res.header("Access-Control-Allow-Origin", origin)
									res.header("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE")
								}

								res.send(200)
							})

						- app.use(cors({
							origin: (origin, callback) => {
							  const ACCEPTED_ORIGINS = [
								"http://localhost:8000",
								"http://localhost:8001"
							  ]
							}

							if(ACCEPTED_ORIGINS.includes(origin) || !origin) { return callback(null, true)}

							if(!origin) { return callback(null, true)}

							return callback(new Error("Not allowed by CORS"))
						  }))

black and decker rice cooker RC550S
